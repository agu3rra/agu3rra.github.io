{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my Blog!","text":"<p>I'm passionate about software development, and infrastructure, with a strong focus on security and automation. Programmatically solving problems is what I like to do best. Python \ud83d\udc0d is my primary language of choice and I'm a huge fan of its community and how it allows one to solve complex problems in a simple fashion.</p> <p>I wrote this blog in an attempt to share topics that I've seen come up repeatedly in discussions with peers. The main idea is to spread a bit of what I learned over the years.</p> <p>Checkout my Github profile to see what I've been up to. Feel free to send me a connection request on LinkedIn if you want to keep in touch.</p> <p>Cheers! \\o/</p>"},{"location":"dev/netrc/","title":"Authentication using a <code>.netrc</code> file","text":"<p>There's many different ways to setup authentication on GIT: SSH keys and personal access tokens when setting up a git remote are pretty straightforward, but my preferred one is using a <code>.netrc</code> file. It works pretty much the same whether you're setting up your local workstation or a CICD pipeline somewhere like Jenkins or AzureDevOps and it also works for fetching Golang dependencies which rely on <code>git</code> (when using <code>go get</code>).</p>"},{"location":"dev/netrc/#the-concept","title":"The concept","text":"<p>The first time I stumbled upon <code>.netrc</code> was in this documentation by IBM. It consists of a specific file (yes, <code>.netrc</code>) which resides in the <code>$HOME</code> directory of a Unix system and allows the computer to authenticate to different machine hosts for a variety of services (e.g.: git, ftp, etc.).</p> <p>Added bonus!</p> <p>You can setup access to multiple hosts using different accounts.</p>"},{"location":"dev/netrc/#on-unix","title":"on Unix","text":"<ol> <li>Open a terminal.</li> <li>Navigate to your <code>$HOME</code> folder by <code>$ cd $HOME</code> or <code>$ cd ~</code></li> <li>Create a <code>.netrc</code> file there with the following contents (one line per host). <pre><code>machine mvs1.tcp.raleigh.ibm.com login tonystark password ironman\nmachine 9.67.112.25 login tonystark password foobar\nmachine github.com login &lt;yourId&gt; password &lt;yourPersonalAccessToken&gt;\nmachine github.acme.com login &lt;yourId&gt; password &lt;yourPersonalAccessToken&gt;\n</code></pre></li> <li>DONE! Now the terminal is \"aware\" of which credentials to use where for different network services.</li> </ol> <p>As you can see a host can be a DNS name entry, IPv4 or IPv6 address. One special thing about GitHub is that you should set it up using a token instead of you regular GitHub account password.</p> <p>Where do I get a GitHub token?</p> <p>GitHub shows you the steps on this documentation.</p> <p>Warning</p> <p>Treat your access tokens like passwords. Don't ever commit them to source control or share them. If that happens rotate them immediatelly. Also consider using more selective token scopes instead of granting tokens access to everything. GitHub allows you to do that via OAuth scopes.</p>"},{"location":"dev/netrc/#on-windows","title":"on Windows","text":"<p>Oh, so you're running Windows? Fear not, we've got you covered!</p> <p>As windows has different environment variables, we need to have it point what it considers a user's <code>HOME</code> folder, here's how you can create <code>.netrc</code>:</p> <ol> <li>Open a command prompt or PowerShell terminal.</li> <li>setup <code>HOME</code> to point to Windows' version of it by running <code>setx HOME %USERPROFILE%</code>.</li> <li>run <code>echo %HOME%</code> and verify it points to the current user's <code>HOME</code> folder (e.g.: <code>C:\\Users\\YOURNAME</code>).</li> <li>Create a <code>_netrc</code> instead of a <code>.netrc</code> file same as on step #3 for unix.</li> </ol>"},{"location":"dev/netrc/#done","title":"Done","text":"<p>Now you can <code>git clone https://...</code> instead of using <code>ssh</code> (as it's common practice in companies to disable SSH services), <code>go get</code> Golang libraries that are behind a GIT server that requires authentication and save the planet among other things.</p> <p></p>"},{"location":"projects/volpy/","title":"Volume Calculations for Digital Elevation Models in Python (volpy)","text":"<p>The purpose of this Python project is to provide the means of calculating volumes out of a Digital Elevation Model (DEM) represented by Triangulated Irregular Network (TIN).</p> <p>Its main goal is to provide sufficiently accurate volume estimates out of terrain surveys for an area of construction work where ground leveling is required prior to the actual construction activity.</p> <p>Source code</p> <p>Available at: https://github.com/agu3rra/volpy</p>"},{"location":"projects/volpy/#preview","title":"Preview","text":""},{"location":"projects/volpy/#installation","title":"Installation","text":"<pre><code>$ pip install volpy\n</code></pre>"},{"location":"projects/volpy/#quick-demo","title":"Quick demo","text":"<pre><code>import volpy as vp\nvp.demo()\n</code></pre>"},{"location":"projects/volpy/#simple-use-case","title":"Simple use case","text":"<pre><code>import volpy as vp\nsurvey = vp.load_survey('survey_data.csv')\nmesh = vp.terrain_mesh(survey.data)\nsurvey.get_bounds()\n&gt; 'x=250.13, y=402.14, z=11.54'\n# Survey plots\nplots = vp.terrain_plots(survey)\nplots.scatter3d()\nplots.contour()\nplots.profile()\nplots.mesh_plot()\nvol_curves = mesh.get_volume_curves(step=1.0)\nmesh.plot_curves(vol_curves)\n\n# Just a volume from the mesh\nmesh.get_volume()\n</code></pre> <p>By default, volpy applies its calculations on a Cartesian Coordinate System. If you are working with survey data obtained from a GPS, its points are likely represented in a Geographic Coordinate System. In order to convert it, use the following modifier when loading the data.</p> <pre><code>survey = vp.load_survey(\n    'survey_data.csv',\n    coordinates=vp.CoordinateSystem.GEOGRAPHIC\n)\n</code></pre>"},{"location":"projects/volpy/methodology/","title":"Methodology","text":""},{"location":"projects/volpy/methodology/#key-definitions","title":"Key Definitions","text":""},{"location":"projects/volpy/methodology/#terrain-survey","title":"Terrain survey","text":"<p>A process by which points are collected from a terrain of interest in order to form a representation of it.</p>"},{"location":"projects/volpy/methodology/#ground-leveling","title":"Ground leveling","text":"<p>In the context of construction, ground leveling is a process by which a given terrain can be re-shaped to a desired projected shape, slope or level. It is usually carried out by the use of heavy machinery to move terrain materials either from the inside the terrain (redistribution of soil) or by using material from the outside.</p>"},{"location":"projects/volpy/methodology/#cutfill-volumes","title":"Cut/Fill volumes","text":"<p>In the context of ground leveling, cut volume refers to terrain material that needs to be removed in order to contribute to re-shape the terrain a new desired state. It is about removing excess. Conversely, fill volumes represent material that needs to be added to the terrain towards achieving this same goal. In practical terms, it is about covering the holes in the terrain.</p>"},{"location":"projects/volpy/methodology/#volume-calculation-method","title":"Volume Calculation Method","text":"<p>During most undergrad studies people are taught how to calculate integrals on a number of different equations. But the real world doesn't give us equations, we need to come up with the equations to model it. This was one of the most delightful pieces of this project: translating a set of points in space into equations and applying basic concepts of linear algebra and integral calculus to them to obtain volumes and cut/fill curves that can be put to practical use in construction work involving earthworks.</p>"},{"location":"projects/volpy/methodology/#in-a-nutshell","title":"In a Nutshell","text":"<ol> <li>From points to a triangles.</li> <li>From triangles to plane equations.</li> <li>From triangles and planes to a sum of volumes.</li> </ol>"},{"location":"projects/volpy/methodology/#step-1-from-points-to-triangles","title":"Step 1: From points to triangles","text":"<p>The sequence of points in 3D space represented each by an <code>(x,y,z)</code> triplet is grouped in a mesh grid using Delaunay triangulation in the <code>(x,y)</code> coordinates. This process outputs a collection of points grouped in 3 sets of 3d coordinates, each representing a triangular plane in 3d space:  </p> \\[ [A,B,C] = [(x_A,y_A,z_A), (x_B,y_B,z_B), (x_C,y_C,z_C)] \\] <p>This is what it looks like when viewed from the top:  </p>"},{"location":"projects/volpy/methodology/#step-2-from-triangles-to-plane-equations","title":"Step 2: From triangles to plane equations","text":"<p>The plane equation <code>z=f(x,y)</code> is obtained for each group of 3 distinct points (triangles) in 3d space by applying some basic linear algebra. Given the previous collection of points <code>[A, B, C]</code> in the cartesian system:</p> <ol> <li>Vector AB and BC are determined using their coordinates.</li> <li>The cross product AB x BC generates a perpendicular vector represented by numerical constants <code>(p,q,r)</code>.</li> <li>Finally the corresponding plane equation is given by:  </li> </ol> \\[ p*(x-xo) + q*(y-yo) + r*(z-zo) = 0 \\] <p>where <code>(xo,yo,zo)</code> can be any one of the 3 A, B or C points from the plane.</p> <p>In the GIF below, the ABC triangle is represented by the blue points and the orthonormal vector <code>(p, q, r)</code> is represented by the blue line with an orange tip.</p> <p></p>"},{"location":"projects/volpy/methodology/#step-3-from-triangles-and-planes-to-a-sum-of-volumes","title":"Step 3: From triangles and planes to a sum of volumes","text":"<p>Given the plane equation, we can isolate z and obtain a <code>z=f(x,y)</code> function on top of which the double integral is applied in order to calculate the volume beneath the triangular plane down until the plane perpendicular to the XY axis that passes by the lowest elevation coordinate (z) of the survey.  </p> <p>The volume of each individual triangle is obtained by the sum of 2 double integrals. So for a triangle with vertices ABC and its plane determined by <code>z=f(x,y)</code> the double integral limits for a single triangular area are determined as follows:</p> \\[ \\operatorname{vol_{triABC}} = \\iint\\limits_{xa AB}^{xb AC} z.dy.dx + \\iint\\limits_{xb AC}^{xc BC} z.dy.dx \\]"},{"location":"projects/volpy/methodology/#from-gps-to-cartesian-coordinates","title":"From GPS to Cartesian Coordinates.","text":"<p>In the event of the terrain survey being executed thru a GPS device (the most common case) an extra step is required prior to applying the volume calculation: map projection.</p> <p>For the purpose of this project the Universal Traverse Mercator was used to convert from GPS coordinates (latitude, longitude, elevation) to a Cartesian coordinate system which is expected by the algorithm in step 1.</p>"},{"location":"security/pragmaticST/article/","title":"Pragmatic Security Testing","text":"<p>8 min read</p>"},{"location":"security/pragmaticST/article/#intro","title":"Intro","text":"<p>It is a consensus in the software community that performing security testing continuously and earliest in the development process (aka shifting left) is ideal as it prevents vulnerabilities from creeping into code and therefore reduces the costs of having to fix them late in the process. This article seeks to provide an overview of different security scanners available and practical use strategies to establish a good development workflow.</p> <p></p> <p>Photo by Ludovic Toinel on Unsplash</p>"},{"location":"security/pragmaticST/article/#your-precious-armory","title":"Your precious armory","text":""},{"location":"security/pragmaticST/article/#sast-static-application-security-testing","title":"SAST (Static Application Security Testing)","text":"<p>SAST tools are the ones that rely mainly on having access to an application's code and running a set of rule checks to detect vulnerable coding patterns or even code quality issues. There's a wide range to choose from open-source language-specific libraries and vendor applications that usually cover a wide range of programming languages. A comprehensive list of available tools is available on the OWASP website.</p>"},{"location":"security/pragmaticST/article/#sca-software-composition-analysis","title":"SCA (Software Composition Analysis)","text":"<p>SCA tools can build a Software Bill of Materials (SBOM) by either looking at manifest files (<code>package.json</code>, <code>requirements.txt</code>, <code>go.mod</code>, <code>pom.xml</code>, etc.) or even at the final binary or container image of the software. These are usually employed to detect vulnerabilities in open-source libraries consumed by your application and are also capable of determining license risks associated with them when you're developing commercial software. Examples include Snyk.io, Whitesource, Blackduck, Nexus Intelligence, and Docker SBOM (experimental).</p>"},{"location":"security/pragmaticST/article/#dast-dynamic-application-security-testing","title":"DAST (Dynamic Application Security Testing)","text":"<p>DAST tools are point-n-shoot scanners that target a running application with a sequence of attacks and try to determine vulnerabilities based on the responses it gets. My personal experience with vendor tools in this area was that it would generally yield too many false positives when the scope of attacks was too broad. I  recommend their use for very specific tasks that leave little room for interpretation, like analyzing TLS cipher suites support and HTTP response headers for capturing misconfigurations. Due to its destructive nature on the target system, it's advised that a throwaway type testing environment be configured for such type of tool.</p>"},{"location":"security/pragmaticST/article/#iast-interactive-application-security-testing","title":"IAST (Interactive Application Security Testing)","text":"<p>IAST tools also target a running system, but unlike DAST these usually have an agent providing instrumentation from within the target. Its goal is to enable more accurate results and overcome some of the limitations of SAST/DAST by combining both.</p>"},{"location":"security/pragmaticST/article/#manual-tools","title":"Manual tools","text":"<p>Manual testing can take many forms. From the browser's built-in Developer Tools to proxy applications that can monitor and manipulate HTTP traffic like OWASP ZAP and Portswigger's BURP, these usually require more in-depth knowledge of software security and are also more time-consuming to conduct. Tools in this category facilitate testing, but the ideas on what to do come from the person conducting them. Consistency is not something they can provide as results will vary with the experience of the pentester.</p>"},{"location":"security/pragmaticST/article/#specific-testing-routines","title":"Specific testing routines","text":"<p>As we learn the weak points of our application, we can also grow the number of unit or integration tests that comprise our regular testing suite to include security-specific scenarios. For instance, by providing a SQL injection type input and evaluating if the application detects it and responds accordingly.</p>"},{"location":"security/pragmaticST/article/#strategies","title":"Strategies","text":""},{"location":"security/pragmaticST/article/#ide-linters","title":"IDE Linters","text":"<p>The best possible flow is the one that enables developers to take action without even having to leave their Integrated Development Environment (IDE). The scanner works almost like a virtual companion by providing issues and suggested fixes as code is written. You cannot shift any more left than this. As we\u2019re in the realm of looking into code and providing insight SAST and SCA tools may be capable of doing this. In the Python world, I personally really like installing bandit and enabling it as a linter in VSCode (CTRL/CMD + SHIFT + P &gt; Python: Select Linter).</p> <p>What I also like about tools like bandit and hadolint (the latter scans Dockerfiles) is the fact that triages can be provided as code. From an audibility perspective that\u2019s great given source control is able to track who did what and when.</p> <pre><code>import yaml\n\nyaml_file = \"some_path_provided_by_the_user.yaml\"\nwith open(yaml_file, 'r') as fh:\n    my_yaml = fh.read()\nfoo = yaml.load(my_yaml)  # nosec Bandit B506: user input has been previously sanitized.\n</code></pre> <p>Example of a triaged vulnerability in python code using bandit. B506 highlights that the load() method in the pyyaml library is vulnerable when consuming user-provided input. Adding <code># nosec</code> as part of the comment, informs the scanner that the issue is to be ignored.</p> What is triaging? <p>That\u2019s when a human assesses an issue to determine whether it is exploitable or not. In case there are possible mitigations these can be applied and provided to explain why a reported vulnerability is being dismissed in a scan report.</p>"},{"location":"security/pragmaticST/article/#pull-requests-prs","title":"Pull requests (PR\u2019s)","text":"<p>Once code is committed and pushed to source control (e.g.: GIT, Mercurial), continuous integration tools (e.g.: Jenkins, GitHub Actions, Azure DevOps, CircleCI, Travis etc) can execute not only the usual testing, build, deploy and release routines but also include security testing.</p> <p>Triggering a security scan on every PR ensures issues can be viewed and addressed even before changes are merged into the <code>trunk/main</code>branch. By opting to break the CICD process in case of issues, you are almost 100% certain to get developers' attention while also ensuring important branches of the code are kept clean.</p> <p>The feasibility of this approach depends on how long the scans take to complete. If the CICD process takes about 15 minutes in total, it makes no sense to trigger a SAST scan that takes about an hour to complete as it\u2019d be too big of an impact on developer productivity. An option, in this case, is to enable what is known as a differential or incremental scan which focuses only on lines of code that are introduced by the PR. The caveat is to assign someone in the team who will ensure full scans are regularly executed and reviewed.</p> <p>Candidate scanners here would include SAST and SCA (manifest-based) on pre-build stages of the CI. Post-build scans could include SCA (binary/image-based) and even DAST/IAST considering a testing environment can be auto-provisioned.</p>"},{"location":"security/pragmaticST/article/#on-merge-to-trunkmain-branch","title":"On merge to <code>trunk/main</code> branch","text":"<p>When scans take too long to finish or the number of developers working on the code concurrently is too high a good balanced approach is to configure them to trigger on commits to <code>trunk/main</code> branch. </p> <p>The drawback here is that security issues are only detected after changes on PR\u2019s are reviewed and merged. So the fix-flow involves submitting a new PR and going thru a review process once issues are addressed.</p> <p>The same scanners applicable in the PR strategy (above) can also be used here.</p>"},{"location":"security/pragmaticST/article/#on-a-scheduled-routine-cron-job","title":"On a scheduled routine (CRON job)","text":"<p>The last option is to put all the scans to run on a schedule (once a day, a week, etc). Visibility is the major concern in this type of strategy given that scheduled jobs can often go unnoticed by the development team and issues remain unaddressed. Additionally, this option tends to cause issues to accumulate until someone decides to do something about them. Like in the previous section, all scanners but the manual type can be employed.</p>"},{"location":"security/pragmaticST/article/#closing-remarks","title":"Closing remarks","text":"<p>It\u2019s important to note that there\u2019s no silver bullet when it comes to security scanning. Each strategy has its pros and cons and feasibility also depends on the workflow of the development team. The main goal is to strive for a balance that enables thoroughness while keeping productivity high.</p> <p>What if triaging conditions change?</p> <p>A common scenario when triaging open-source software libraries is to dismiss a vulnerability when the exploitability conditions are not met. If a vulnerable method is not used, then your code is safe. But consider for a moment that a software project is ever-evolving and that teams change. In the future, a new team member may introduce that specific method that is vulnerable therefore putting the project at risk. </p> <p>This is one of the reasons why it\u2019s always a good idea to patch open-source dependencies regularly. As new vulnerabilities come out and the community works on providing fixes, you\u2019re automatically incorporating them into your project.</p> <p>Another good idea is to establish a regular review process of all triaged issues to ensure mitigation conditions are still met.</p>"},{"location":"security/proxyIos13/article/","title":"How to set up a proxy for security testing in iOS13","text":"<p>4 min read</p> <p>So you want to hunt for bugs in Bug Bounty programs that allow testing of iOS applications, but couldn\u2019t figure out how to take a pick on traffic coming out of your device? You\u2019ve come to the right place! :)</p> <p>DISCLAIMER</p> <p>Beware that testing any systems without proper authorization is illegal. I trust you will use the information contained in this article appropriately.</p> <p>Info</p> <p>At the time I wrote this article (in late 2021?), some proxy applications' default generated certificate was not accepted by iOS 13. That has now changed, but I decided to keep this article up since it teaches how to generate a certificate yourself in case you need it for other situations.</p> <p> Photo by Yura Fresh on Unsplash</p>"},{"location":"security/proxyIos13/article/#ios-13s-new-certificate-requirements","title":"iOS 13\u2019s new certificate requirements","text":"<p>The security requirements around certificates have been a bit tightened on iOS13. In this article, I will walk you through how to generate a certificate that is accepted in devices with the latest iOS update and how/where to configure it. This should enable you to pick on HTTPS traffic in and out of apps in Apple\u2019s ecosystem.</p> <p>Update</p> <p>Default certificates bundled with security testing tools such as OWASP Zed Attack Proxy (aka. ZAP) or BURP did not adhere to these standards shortly after iOS 13 was launched. They do now, so you can simply use the certificate generated by these tools and import them into iOS using steps 3 and 4 described here. I\u2019ll keep this article published for reference in case something similar happens in a future iOS release.</p> <p>Thank you to the folks who brought this to my attention! :)</p>"},{"location":"security/proxyIos13/article/#what-we-are-aiming-to-achieve","title":"What we are aiming to achieve","text":"<p>A configuration setup that will redirect any communication traffic from an iOS13 device to a personal computer before reaching application servers that enable any given iOS app to work:</p> <p>iOS device \u2190 \u2192 Computer with ZAP \u2190 \u2192 Application Servers</p> <p>I am assuming your local network has internet connectivity and that your iOS and computer are in the same network.</p>"},{"location":"security/proxyIos13/article/#required-steps","title":"Required steps","text":"<ol> <li>Generate a self-signed certificate</li> <li>Import the certificate to your proxy tool (we\u2019ll use ZAP).</li> <li>Import the same certificate into iOS\u2019 certificate store and have it enabled as trusted.</li> <li>Manually override your iOS\u2019 network settings to proxy traffic to your computer.</li> </ol> <p>If all works out, you should be able to see all HTTPS traffic that flows while you use apps on your iOS device.</p>"},{"location":"security/proxyIos13/article/#detailed-steps","title":"Detailed steps","text":""},{"location":"security/proxyIos13/article/#generating-a-self-signed-certificate","title":"Generating a self-signed certificate","text":"<p>I am working on a Windows PC and I have previously installed GIT for Windows which enables me to run the following openssl commands from Git Bash to get myself a self-signed certificate.</p> <pre><code>$ openssl genrsa -out ca.key 2048\n$ openssl req -days 365\\\n              -key ca.key\\\n              -x509 -new -nodes -sha256 \n              -out ca.pem\n$ cat ca.key &gt; certificate_zap.pem\n$ cat ca.pem &gt;&gt; certificate_zap.pem\n$ sed 's/RSA //' certificate_zap.pem &gt; certificate_zap_final.pem\n</code></pre> <p> Generating certificate from git bash</p>"},{"location":"security/proxyIos13/article/#importing-it-into-zap","title":"Importing it into ZAP","text":"<p>Use the <code>certificate_zap_final.pem</code> file generated in the previous step as the certificate that is presented by your proxy to iOS. For that, launch ZAP (2.9.0 at the time of this writing), find the Tools &gt; Options &gt; Dynamic SSL Certificates menu, and use the Import button.</p> <p>Note</p> <ol> <li>ZAP requires the private key and the certificate to be in the same file. Additionally, it also asks that the private key part be in an exact format, which is the reason why I had to run the cat and sed commands in the previous step.</li> <li>If you want to use BURP instead of ZAP, the following command generates a PKCS#12 keystore to import the certificate into it:</li> </ol> <p>$ openssl pkcs12 -export -out burpcert.pfx -inkey ca.key -in ca.pem</p>"},{"location":"security/proxyIos13/article/#importing-the-certificate-into-ios","title":"Importing the certificate into iOS","text":"<p>Email the <code>ca.pem</code> file generated previously to your iOS device. Opening it on Apple\u2019s Mail app is the easiest way to get it installed into your device as what is called a Profile. In iOS, simply click the ca.pem file inside the Mail app to download the new Profile. Then go to the Settings &gt; General &gt; Profile menu and complete the installation of the certificate. Finally, go to Settings &gt; General &gt; About &gt; Certificate Trust Settings and enable full trust of the certificate.</p> <p> Reference screenshots from an iOS device</p>"},{"location":"security/proxyIos13/article/#redirecting-traffic","title":"Redirecting traffic","text":"<p>Access Settings &gt; Wi-Fi, click the info sign beside your Wi-Fi network and access the Configure Proxy session. Select Manual and specify the IP address of your computer as the server and the proxy port you\u2019re using in ZAP to serve it as a proxy (default is 8080).</p>"},{"location":"security/proxyIos13/article/#congratulations","title":"Congratulations!","text":"<p>And you\u2019re done! If you launch any application on your iOS device now, all HTTP traffic should be visible in ZAP.</p> <p> Sample traffic upon opening Pinterest on iOS</p>"},{"location":"security/proxyIos13/article/#references","title":"References","text":"<ul> <li>https://support.apple.com/en-us/HT210176</li> <li>https://owasp.org/www-project-zap/</li> <li>https://portswigger.net/burp</li> </ul>"},{"location":"security/pythonCustomsCAs/article/","title":"Trouble using Python to access HTTP corporate services because of internal CA\u2019s?","text":"<p>3 min read</p>"},{"location":"security/pythonCustomsCAs/article/#the-problem","title":"The problem","text":"<p>If you have used any of Python\u2019s HTTP libraries such as requests or urllib you may have stumbled upon the CERTIFICATE_VERIFY_FAILED error. One of the possible causes is the service you are connecting to uses either a certificate that was self-signed or issued by a Certificate Authority (CA) that is not publicly recognized. The latter is very common in corporate intranet services, so if you\u2019re building an application to talk to these you must \u201ctell\u201d Python that its CA is trusted.</p> <p>Info</p> <p>PS: I did the following with Python 3</p> <p> Photo by Scott Warman on Unsplash</p>"},{"location":"security/pythonCustomsCAs/article/#why-does-it-happen","title":"Why does it happen?","text":"<p>Python scripts don\u2019t use the operating system\u2019s built-in certificate store to establish trust when securing channels to services it wishes to communicate with. These are kept in a file called <code>cacert.pem</code>, inside the install path of the <code>certifi package</code>. All you have to do is import (copy/paste) the CA or self-signed certificate to that file and you should be able to connect to a service that makes use of it.</p>"},{"location":"security/pythonCustomsCAs/article/#who-do-you-trust","title":"Who do you trust?","text":"<p>Your computer\u2019s operating system comes pre-loaded with a list of public known CA\u2019s (e.g.: DigiCert, GoDaddy etc) so that a website served using HTTPS can be accessed. The catch is: there are lots of different places that a given program may be using as its source of trusted CA\u2019s.</p> <p>Tip</p> <p>If you wish to know more about a CA and how that trust relationship works and most importantly the implications of adding another CA to your trust store, try reading this article.</p>"},{"location":"security/pythonCustomsCAs/article/#where-does-python-keep-its-cas","title":"Where does Python keep its CA\u2019s?","text":"<p>In the <code>cacert.pem</code> file. To locate it, all you have to do is find the install path of Python\u2019s standard <code>certifi</code> package. The easiest route I know for that is simply opening a Python REPL (<code>$ python</code>) and typing the following:</p> <pre><code>$ python\n&gt;&gt;&gt; import certifi\n&gt;&gt;&gt; path = certifi.__path__[0]\n&gt;&gt;&gt; print(path)\n</code></pre> <p> Where is cacert.pem?</p>"},{"location":"security/pythonCustomsCAs/article/#ok-i-found-certifis-path-now-what","title":"Ok, I found certifi\u2019s path. Now what?","text":"<p>Append the Base64 encoded certificate data to it. This does look like a bit of a mouthful, but it is quite simple. Base64 encoding is simply a sequence of characters that represents all of the certificate\u2019s information. As an example, I\u2019m going to save Medium\u2019s CA in that format by executing the following steps:</p> <ol> <li>Access the site or service you with to communicate to.</li> <li>Click the padlock icon, then on the certificate to view it.</li> <li>Access the Certification Path, select the certificate that you wish to save then View Certificate.</li> <li>Access the Details tab and finally Copy to File.</li> <li>Open the certificate file and copy its contents to the <code>cacert.pem</code> file.</li> </ol> <p> Saving a certificate\u2019s CA from the browser</p> <p> Opening a certificate\u2019s CA in Base64 format using VSCode</p>"},{"location":"security/pythonCustomsCAs/article/#try-it-yourself","title":"Try it yourself","text":"<p>You should now be able to copy the contents of the PEM file obtained above into the <code>cacert.pem</code> file that Python uses. Then your Python libraries should be able to call services that were signed by the custom CA or self-signed certificate.</p> <p>If you found any errors or have anything you\u2019d like to see added to this article, please feel free to create an issue here.</p> <p>Thanks for reading!</p>"},{"location":"security/tlsHandshake/article/","title":"TLS Handshake: a secretive way to say hello","text":"<p>5 min read</p>"},{"location":"security/tlsHandshake/article/#introduction","title":"Introduction","text":"<p>The objective of this article is to demystify the process by which most applications exchange a secret and establish a secure communication channel in an insecure medium such as the Internet. It also attempts to shed some light on the role a Certificate Authority (CA) plays in the process.</p> <p> Cartoon by Phil Johnson. Used with previous authorization.</p>"},{"location":"security/tlsHandshake/article/#the-need-for-a-secret","title":"The need for a secret","text":"<p>Encryption is not something of the Internet age. One of the very first encryption methods we learn at whatever tech school of choice is the famous Caesar Cipher, a method devised at the times of the Roman empire to transmit secret war messages without disclosing it to either the messenger or anyone other than its intended audience. The process consisted in shifting the letters of the alphabet by a fixed amount in order to scramble the message. We\u2019re not diving into any advanced mathematics here, but for the sake of example let me illustrate it with a simple message Caesar may want to send to one of his generals, Gen. Maximus:</p> <p>Plain text message:</p> <p>\"Divide the army in two, advance and outflank them on the right. I will advance on the left flank from the woods getting them by surprise.\"</p> <p>Assuming the secret text shift is 6, the letter A is replaced by G, B by H and so on. So the encrypted text (ciphered message) would look like this (removing spaces and punctuation):</p> <p>Ciphered text:</p> <p>\"JobojkznkgxseotzcugjbgtikgtjuazlrgtqznksutznkxomnzOcorrgjbgtikutznkrklzlrgtqlxusznkcuujymkzzotmznksheyaxvxoyk\"</p> <p>Once the message reached Gen. Maximus, all he had to do to retrieve the original message was to replace the letters from the ciphered message according to the pre-established shift amount. So the letter J is replaced by D, and so on.</p> <p>As you may have noticed, both the sender and the recipient need to know a common secret. In this case, both have to know that the message is using shifted text letters by a factor of 6. This is one of the most rudimentary forms of symmetric encryption, a method in which the same secret serves to both scramble and unscramble the message. So the next obvious problem becomes: how do I exchange a secret between two communication parties using an insecure channel? How could Caesar tell Maximus that all his messages would have letters shifted by a factor of 6? Enter Asymmetric encryption, also known as Public-key cryptography!</p> <p>Watch out!</p> <p>The Caesar Cipher is easily broken and in modern practice offers no communication security at all. We\u2019re using it here for the sake of example and to keep the concept simple.</p>"},{"location":"security/tlsHandshake/article/#asymmetric-encryption","title":"Asymmetric encryption","text":"<p>The way asymmetric encryption solves the secret exchange problem comes from the fact that the value it uses to scramble/encrypt a clear text message is different than the one it uses to unscramble/decrypt it. The first is dubbed the public key and the second the private key. The mechanics of the process goes as follows. We\u2019ll keep using the Caesar and General Maximus example:</p> <ol> <li>Caesar signals he wishes to communicate.</li> <li>Maximus sends a public key so that Caesar can encrypt a message containing a secret and send it back.</li> <li>Maximus uses his private key to reveal the secret both him and Caesar will use in all the next message exchanges. The secret is: \"Use the Caesar cipher with a shift of 6\".</li> </ol> <p>The above process is what a TLS Handshake is: an exchange of messages that serves the purpose of securely trading secrets between 2 parties. If the message is intercepted between steps 2 and 3, the secret (Caesar cipher with shift of 6) is still safe since only Maximus holds the private key that reveals it.</p> <p>Info</p> <p>public and private keys are mathematically paired with one another, but the details and explanation are not in the scope of this article.</p>"},{"location":"security/tlsHandshake/article/#the-certificate-authority","title":"The Certificate Authority","text":"<p>What if the initial handshake message from Caesar had arrived at someone from the enemy army before it reached Maximus? Upon receiving the first response, how could he be sure that he was talking to Maximus on the other end? The answer is that Maximus uses a Roman empire seal of authenticity that he was sent along with his message and that the enemy couldn't forge. That seal established a trusting relationship between Caesar and whoever was on the other end of the line. That is the role of a Certificate Authority (CA): a 3<sup>rd</sup> party one can trust (the Roman empire\u2019s seal emitter) that attests that the public key being used in the TLS handshake process belongs to a specific server (Maximus), so the party that initiated the communication (Caesar) can perform the exchange of the secret to be used in further messages.</p>"},{"location":"security/tlsHandshake/article/#faqs","title":"FAQ\u2019s","text":"Why don\u2019t we just use asymmetric encryption? <p>Because it is much slower. Asymmetric encryption is usually applied for the initial secret exchange that will be the key for encrypting/decrypting further messages using symmetric encryption. A long enough random secret being used as a symmetric encryption key is secure enough.</p> What is a self-signed public certificate and why is it dangerous to import one to the computer\u2019s trust store? <p>Ans.: Certificate Authorities are like notary offices on the internet. Accepting a self-signed certificate would be like accepting a driver\u2019s license printed on a sheet of common paper by a 15-year-old stating he/she was 21. Not only that, but you\u2019d be accepting any other type of document printed in the common 15-year-old printer as valid. The main security implication for that in a computer would be that if your messages were intercepted (say for a bank transaction) by a malicious player on what is known as a man-in-the-middle attack you\u2019d fail to get a common warning sign in that attack scenario: the red padlock. As almost all internet communications (at least should) take place in an encrypted channel using HTTPS, the validity of a certificate used to be shown in the browser as a green padlock, which confirmed you were exchanging messages with the server you meant to communicate with. Some modern browsers today no longer show the green/red padlock, they instead display a big block page in case something is wrong with the certificate.</p>"},{"location":"security/tlsHandshake/article/#caesars-cipher-in-python","title":"Caesar\u2019s cipher in Python","text":"<p>Here\u2019s a simple implementation of the Caesar\u2019s cipher in Python for the above example. Feel free to run it and see it in action for yourself.</p> <pre><code>message = 'Divide the army in two, advance and outflank them on the right. I will advance on the left flank from the woods getting them by surprise.'\nmessage = message.replace(' ','')\nmessage = message.replace(',','')\nmessage = message.replace('.','')\nshift_secret = 6\nciphered_message = ''\nprint(message)\nfor character in message:\n    if character.isupper():\n        ciphered_message += chr((ord(character) + shift_secret - 65) % 26 + 65)\n    else:\n        ciphered_message += chr((ord(character) + shift_secret - 97) % 26 + 97)\n</code></pre>"},{"location":"security/tlsHandshake/article/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Caesar_cipher</li> <li>https://en.wikipedia.org/wiki/Public-key_cryptography</li> <li>https://en.wikipedia.org/wiki/HTTPS</li> <li>https://www.tutorialspoint.com/cryptography_with_python/cryptography_with_python_caesar_cipher.htm</li> </ul>"},{"location":"security/vulnsOSS/article/","title":"Tackling vulnerabilities in open-source","text":"<p>5 min read</p> <p>So you\u2019re keeping track of all the open-source dependencies (aka libraries) in your software and you found a vulnerability. Well... consider yourself lucky, because I usually find a whole bunch of them! Jokes aside, this article will talk about the possible ways of dealing with it.</p> <p></p> <p>Photo by Katrina Berban on Unsplash.</p>"},{"location":"security/vulnsOSS/article/#direct-vs-transitive-dependencies","title":"Direct Vs. Transitive dependencies","text":"<p>The different possible dependency paths a vulnerability comes from play a role in the difficulty level of how to treat it. Direct dependencies are those that you explicitly add to your code. Since software is commonly built on top of pre-existing software, libraries you pull directly will often have direct dependencies of their own. These will be considered transitive or indirect dependencies and they can be nested several levels down the supply chain as even your indirect dependencies can have dependencies of their own.</p> <p>Warning</p> <p>Manifest files containing semver (semantic versioning) do not tell you the actual library version you consume. If you want to double-check check in the code, refer to lock files (e.g.: <code>package-lock.json</code>, <code>Pipfile.lock</code>, <code>go.sum</code> etc). Different package management systems may allow multiple versions of the same library to be consumed. Some will also allow you to force specific versions of a library despite the main dependency manifest requiring a different version.</p>"},{"location":"security/vulnsOSS/article/#what-is-a-cve","title":"What is a CVE?","text":"<p>The mission of the CVE\u00ae Program is to identify, define, and catalog publicly disclosed cybersecurity vulnerabilities. A CVE (Common Vulnerabilities and Exposures) is basically a unique identifier for a security vulnerability in a piece of software. The CVE program is funded by the U.S. Department of Homeland Security. An extended technical description of the vulnerabilities, attack vectors, additional links, and severity score (scale from 0 to 10) are all maintained at the National Vulnerability Database (NVD). </p> <p></p> <p>In the example CVE record above taken from the NVD for the <code>pandas</code> library, you can find information such as the severity score and different factors that contributed to it. Additionally, you can observe that versions above 1.0.3 are not affected by it and also that the vulnerable method is <code>read_pickle()</code>.</p>"},{"location":"security/vulnsOSS/article/#the-3-alternatives-to-deal-with-vulnerable-libraries","title":"The 3 alternatives to deal with vulnerable libraries","text":""},{"location":"security/vulnsOSS/article/#1-remove","title":"1. Remove","text":"<p>Perhaps the library for which you got a vulnerability report in your software was just there for testing purposes and you actually don\u2019t even use it. So simply remove it. Less is more when it comes to managing dependencies in software.</p>"},{"location":"security/vulnsOSS/article/#2-patch","title":"2. Patch","text":"<p>Sometimes a patch is already available by the time you detect a vulnerability. In the previous example for the <code>pandas</code> library (CVE-2020-13091) a patch to any version above 1.0.3 would fix it. When a patch is not available for a piece of open-source software you use, you can always work on a fix yourself and contribute back to the community by making something you rely on more secure.</p> <p>Fixing yourself obviously involves more work and to illustrate how direct vs. transitive dependencies play a role in this, let\u2019s use an example. The output below was obtained after installing 3 separate python libraries (direct dependencies) via pipenv and running the <code>pipenv graph</code> command:</p> <pre><code>pandas==1.4.2\n  - numpy [required: &gt;=1.21.0, installed: 1.22.3]\n  - python-dateutil [required: &gt;=2.8.1, installed: 2.8.2]\n    - six [required: &gt;=1.5, installed: 1.16.0]\n  - pytz [required: &gt;=2020.1, installed: 2022.1]\npytest==7.1.2\n  - atomicwrites [required: &gt;=1.0, installed: 1.4.0]\n  - attrs [required: &gt;=19.2.0, installed: 21.4.0]\n  - colorama [required: Any, installed: 0.4.4]\n  - iniconfig [required: Any, installed: 1.1.1]\n  - packaging [required: Any, installed: 21.3]\n    - pyparsing [required: &gt;=2.0.2,!=3.0.5, installed: 3.0.8]\n  - pluggy [required: &gt;=0.12,&lt;2.0, installed: 1.0.0]\n  - py [required: &gt;=1.8.2, installed: 1.11.0]\n  - tomli [required: &gt;=1.0.0, installed: 2.0.1]\nrequests==2.27.1\n  - certifi [required: &gt;=2017.4.17, installed: 2021.10.8]\n  - charset-normalizer [required: ~=2.0.0, installed: 2.0.12]\n  - idna [required: &gt;=2.5,&lt;4, installed: 3.3]\n  - urllib3 [required: &gt;=1.21.1,&lt;1.27, installed: 1.26.9]\n</code></pre> <p>If we identify a vulnerability in <code>six 1.16.0</code>, that needs patching, the community mindset of open-source would tell us to provide a fix to that library (generating version 1.16.1) then have the <code>python-dateutil</code> library consume it (generating version 2.8.3) and finally do the same for <code>pandas</code> so we could finally consume a patched version (<code>pandas 1.4.3</code>). That\u2019s a lot of effort since the vulnerability path was 2 levels down in our transitive dependencies (<code>packaging</code> and <code>pyparsing</code>).</p> <p></p>"},{"location":"security/vulnsOSS/article/#3-mitigate","title":"3. Mitigate","text":"<p>It is also possible that the vulnerability has a mitigation factor in place. There can be other conditions that lessen the overall severity and you decide the risk level is acceptable. I particularly find NVD\u2019s CVSS (Common Vulnerability Scoring System) calculator useful for getting a personalized assessment and severity score depending on how a particular vulnerability can be exploited. For example: the CVE record score states that no privileges are required (PR:N), but you know for a fact that the library can only be reached once a user has gotten past the login screen of your application, so you can use PR:L (low privilege required) to get an updated score for your particular case.</p> <p>And finally, perhaps the exploit condition is not met and the vulnerability cannot be exploited in your software. Going back to the <code>pandas</code> example (CVE-2020-13091), remember that the CVE entry described that the vulnerable method was <code>read_pickle()</code>. So, if you know you\u2019re not calling it anywhere in code, then it should not affect you. A caveat with that is when you\u2019re talking about vulnerabilities in transitive dependencies as it can become difficult to determine if somewhere in your dependency tree calls to that specific method are made indirectly.</p> <p>What if the conditions change?</p> <p>Another important factor to consider is that a method not in use today may be invoked in the future as your software evolves. Once a vulnerability is dismissed, you may re-introduce it and not get a new CVE alert depending on what tool you used to detect it (see post on security scanners). So the best alternative to play it safe is to ensure regular patching is part of your development process.</p>"},{"location":"security/vulnsOSS/article/#references","title":"References","text":"<ol> <li>https://www.redhat.com/en/topics/security/what-is-cve</li> <li>https://www.dhs.gov/</li> <li>https://nvd.nist.gov</li> <li>https://cve.mitre.org</li> <li>https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator</li> </ol>"}]}